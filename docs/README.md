# Vehicle Abstraction Layer - KUKSA.VAL
## Introduction

The **KUKSA.VAL** is a reference implementation of a **Vehicle Abstraction Layer (VAL)** provided by the [Eclipse KUKSA project](https://www.eclipse.org/kuksa/). It offers **Vehicle Applications** downloadable from or even runnable in the cloud to interact with the underlying vehicle hardware and software in a unifom way independent of model, make or even manufacturer. 

A developer of a Vehicle Applications could either call the VAL functions using the gRPC skeletons, generated by the gRPC/protobuf tooling for the desired programming language. A more comfortable way to develop vehicle applications is offered by the Eclipse Velocitas project. It defines an SDK and toolchain to simplify the development of vehicle apps. 
The Velo cares for supporting the developer of an vehicle app to abstract from the gRPC-based access to the VAL. It offers a toolchain and programing language-specific SDKs and data models.


The heart of KUKSA.VAL is the **KUKSA Data Broker** offering a centralited read access to vehicle data (signals, sensors, and other states) structured in a semantic model. Vehicle data can be either read out in pull style or the vehicle aplication can subscribe for state changes (Push style). The subscription allows for referencing a whole set of signals and specifying rules/conditions when the application needs being notified.





It currently consists of a data broker, a CAN feeder and a set of example services.
More elaborate or completely differing implementations are the target of particular derived projects.

## Architecture

The image below shows the main components of the Vehicle Abstraction Layer (VAL) and its relation to the [Velocitas Development Model](/docs/development-model.md).

![VAL architecture overview](val_architecture_overview.png "Overview of the vehicle abstraction layer architecture")

### KUKSA Data Broker

The [KUKSA Data Broker](https://github.com/eclipse/kuksa.val/tree/master/kuksa_databroker) is a gRPC service acting as a broker of vehicle data / data points / signals.
It provides central access to vehicle data points arranged in a - preferably standardized - vehicle data model like the [COVESA Vehicle Signal Specification (VSS)](https://covesa.github.io/vehicle_signal_specification/) or others.
It is implemented in Rust, can run in a container and provides services to get datapoints, update datapoints and for subscribing to datapoints.
Filter- and rule-based subscriptions of datapoints can be used to reduce the number of updates sent to the subscriber.

### Data Feeders

Conceptually, a data feeder is a provider of a certain set of data points to the data broker.
The source of the contents of the data points provided is specific to the respective feeder.

As of today, the Vehicle Abstraction Layer contains a generic [CAN feeder (KUKSA DBC Feeder)](https://github.com/eclipse/kuksa.val/tree/main/kuksa_feeders) implemented in Python,
which reads data from a CAN bus based on specifications in a e.g., CAN network description (dbc) file.
The feeder uses a mapping file and data point metadata to convert the source data to data points and injects them into the data broker using its `Collector` gRPC interface.
The feeder automatically reconnects to the data broker in the event that the connection is lost.

### Vehicle Services

A vehicle service offers a gRPC interface allowing vehicle apps to interact with underlying services of the vehicle.
It can provide service interfaces to control actuators or to trigger (complex) actions, or provide interfaces to get data.
It communicates with the Hardware Abstraction to execute the underlying services, but may also interact with the data broker.

The KUKSA.VAL is providing examples how such kind of vehicle services could be built-up in the [kuksa.val.services repository](https://github.com/eclipse/kuksa.val.services/).

### Hardware Abstraction

Data feeders rely on hardware abstraction. Hardware abstraction is project/platform specific.
The reference implementation relies on **SocketCAN** and **vxcan**, see https://github.com/eclipse/kuksa.val.feeders/tree/main/dbc2val.
The hardware abstraction may offer replaying (e.g., CAN) data from a file (can dump file) when the respective data source (e.g., CAN) is not available.

## Information Flow

The vehicle abstraction layer offers an information flow between vehicle networks and vehicle services.
The data that can flow is ultimately limited to the data available through the Hardware Abstraction, which is platform/project-specific.
The KUKSA Data Broker offers read/subscribe access to data points based on a gRPC service. The data points which are actually available are defined by the set of feeders providing the data into the broker.
Services (like the [seat service](https://github.com/eclipse/kuksa.val.services/tree/main/seat_service)) define which CAN signals they listen to and which CAN signals they send themselves, see [documentation](https://github.com/eclipse/kuksa.val.services/blob/main/seat_service/src/lib/seat_adjuster/seat_controller/README.md).
Service implementations may also interact as feeders with the data broker.


### Data flow when a Vehicle Application uses the KUKSA Data Broker.

![KUKSA data broker data flow](dataflow_broker.png "Architectural representation of the KUKSA data broker data flow")

### Data flow when a Vehicle Application uses a Vehicle Service.

![Vehicle service data flow](dataflow_service.png "Architectural representation of the vehicle service data flow")

## Source Code

Source code and build instructions are available in the [kuksa.val repository](https://github.com/eclipse/kuksa.val).

## Guidelines

- Please see the [vehicle service guidelines](vehicle_service.md) for information on how to implement a Vehicle Service.
- Please see the [interface guideline](interface_guideline.md) for best practices on how to specify a gRPC interface.
